## Student Name: Matthew Magagna
## Student ID: 219804921

Prompt 1: New requirement: At least one resource must remain unallocated after assignment. This requirement applies in addition to all previously described behavior. An allocation that satisifes all other conidtions but consumes all avaiable resources is no longer valid. Update your solution and tests and documents to inorportate this requirement. Do you think your current solution satisifes the new requirement? Which scenarios or cases do you expect to fail under the new requirmeent? what is the most likely cause of failure: misisng constraint, invariant violation, tie breaking/ordering, parsisng/format assumption, other which artifiacts do you expect to update chekc all that apply? requirements/spec (if you have one), code, tests, prompt strategy, other restate the new requirment in on clear sentence i ur own words
LLM Response 1: No, the current solution does not satisfy the new requirement.

Why it doesn’t

Right now the function returns True whenever total demand for every resource is ≤ capacity. It does not check that something is left over. So any case where requests exactly consume every resource will incorrectly return True under the new rule.

Scenarios that will now fail

Any allocation where all available resources are fully consumed, for example:

Single resource exact fill: resources={'cpu': 10}, requests sum to 10

Multi-resource exact fill: resources={'cpu': 8, 'mem': 30}, requests sum to cpu=8 and mem=30

Edge: capacities of 0 across all resources with empty requests would also violate “at least one resource remains unallocated” (nothing can remain).

Most likely cause of failure

Missing constraint (the “must leave slack” rule was not implemented). Not an invariant/tie-break/parsing issue.

Artifacts to update (check all that apply)

✅ requirements/spec (objective/constraints/invariants/negative reqs)

✅ code (is_allocation_feasible)

✅ tests (add new tests + update any that relied on exact capacity being feasible)

✅ other: documentation text you wrote (inputs/outputs/constraints/special rules)

⛔ prompt strategy (not necessary unless you’re using an LLM workflow for generation)

Restate the new requirement (one clear sentence)

The allocation is only feasible if it meets all capacity rules and leaves at least one unit of capacity unused in at least one resource.
--------------------------------------------------
Prompt 2: list as many func requirements as possible from specifcation description
LLM Response 2: Here’s a clean, spec-aligned list of functional requirements, including the new requirement:

The system shall accept a collection of available resources with defined capacities.

The system shall accept a list of resource requests.

Each request shall specify required amounts for one or more resources.

The system shall validate that each request is provided as a dictionary.

The system shall raise a ValueError if any request is not a dictionary.

The system shall treat requests for undefined resources as infeasible.

The system shall aggregate resource demands across all requests.

The system shall determine feasibility on a per-resource basis.

The system shall ensure that total demand for any resource does not exceed its capacity.
--------------------------------------------------

Prompt 3:ist at leas 3 always hold invariants 
LLM Response 3: For every resource, the total allocated amount is less than or equal to its available capacity.

All resource requests reference only valid, defined resources and contain non-negative amounts.

At least one resource retains unused capacity after allocation.
--------------------------------------------------
--------------------------------------------------

Prompt 4: ok give me the new is_allocation feasible function with new requirement
LLM Response 4: def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Args:
        resources : Dict[str, Number], Mapping from resource name to total available capacity.
        requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required.

    Returns:
        True if the allocation is feasible, False otherwise.

    """
    # TODO: Implement this function

    totals: Dict[str, float] = {}

    # Validate capacities and initialize totals
    for r_name, cap in resources.items():
        if not isinstance(cap, (int, float)):
            return False
        if cap < 0:
            return False
        totals[r_name] = 0.0

    # Validate and accumulate requests
    for req in requests:
        if not isinstance(req, dict):
            raise ValueError("Each request must be a dict.")

        for r_name, amount in req.items():
            # Resource must exist
            if r_name not in resources:
                return False
            # Amount must be numeric and non-negative
            if not isinstance(amount, (int, float)):
                return False
            if amount < 0:
                return False

            totals[r_name] += float(amount)

            # Capacity must not be exceeded
            if totals[r_name] > float(resources[r_name]):
                return False

    # NEW REQUIREMENT:
    # At least one resource must remain unallocated (some capacity left over)
    # Allocation is invalid if ALL resources are fully consumed.
    for r_name, cap in resources.items():
        if totals.get(r_name, 0.0) < float(cap):
            return True

    return False

--------------------------------------------------
-------------------------------------------------

Prompt 5:update test cases in tests_solution.py
LLM Response 5: ## Student Name: Matthew Magagna
## Student ID: 219804921

"""
Public test suite for the meeting slot suggestion exercise.

Students can run these tests locally to check basic correctness of their implementation.
The hidden test suite used for grading contains additional edge cases and will not be
available to students.
"""
from src.solution import is_allocation_feasible
import pytest


def test_basic_feasible_single_resource():
    # Basic Feasible Single-Resource
    # Constraint: total demand <= capacity AND at least one unit remains unallocated
    # Reason: check basic functional requirement with new slack rule
    resources = {'cpu': 10}
    requests = [{'cpu': 3}, {'cpu': 4}, {'cpu': 2}]  # total 9, leaves 1
    assert is_allocation_feasible(resources, requests) is True


def test_multi_resource_infeasible_one_overloaded():
    # Multi-Resource Infeasible (one overload)
    # Constraint: one resource exceeds capacity
    # Reason: check detection of per-resource infeasibility
    resources = {'cpu': 8, 'mem': 30}
    requests = [{'cpu': 2, 'mem': 8}, {'cpu': 3, 'mem': 10}, {'cpu': 3, 'mem': 14}]
    assert is_allocation_feasible(resources, requests) is False


def test_missing_resource_in_availability():
    # Missing Resource in Requests
    # Constraint: request references unavailable resource
    # Reason: allocation must be infeasible
    resources = {'cpu': 10}
    requests = [{'cpu': 2}, {'gpu': 1}]
    assert is_allocation_feasible(resources, requests) is False


def test_non_dict_request_raises():
    # Non-Dict Request Raises Error
    # Constraint: structural validation
    # Reason: request must be a dict
    resources = {'cpu': 5}
    requests = [{'cpu': 2}, ['mem', 1]]  # malformed request
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)


"""TODO: Add at least 5 additional test cases to test your implementation."""


def test_exact_capacity_boundary_now_infeasible():
    # Exact Capacity Boundary (NEW RULE)
    # Constraint: consuming all available resources is not allowed
    resources = {'cpu': 5}
    requests = [{'cpu': 2}, {'cpu': 3}]  # total 5, leaves 0
    assert is_allocation_feasible(resources, requests) is False


def test_empty_requests_feasible_if_any_capacity_positive():
    # Empty Requests
    # Constraint: if any capacity > 0, then resources remain unallocated
    resources = {'cpu': 0, 'mem': 10}
    requests = []
    assert is_allocation_feasible(resources, requests) is True


def test_empty_requests_infeasible_if_all_zero_capacity():
    # Empty Requests with all-zero capacities (NEW RULE)
    # Constraint: must leave at least one unit unallocated, impossible if all caps are 0
    resources = {'cpu': 0, 'mem': 0}
    requests = []
    assert is_allocation_feasible(resources, requests) is False


def test_request_missing_some_resources_ok_and_slack_exists():
    # Request Missing Some Resources
    # Constraint: missing keys imply 0 usage; slack must still exist somewhere
    resources = {'cpu': 4, 'mem': 10}
    requests = [{'cpu': 2}, {'mem': 5}]
    assert is_allocation_feasible(resources, requests) is True


def test_slack_in_one_resource_is_enough():
    # Slack in only one resource is sufficient (NEW RULE)
    resources = {'cpu': 5, 'mem': 10}
    requests = [{'cpu': 5, 'mem': 7}]  # cpu fully used, mem has slack
    assert is_allocation_feasible(resources, requests) is True


def test_negative_request_infeasible():
    # Negative Request
    resources = {'cpu': 5}
    requests = [{'cpu': -1}]
    assert is_allocation_feasible(resources, requests) is False


def test_negative_capacity_infeasible():
    # Negative Capacity
    resources = {'cpu': -5}
    requests = [{'cpu': 1}]
    assert is_allocation_feasible(resources, requests) is False


def test_float_amounts_supported_and_slack_exists():
    # Float Amounts Supported
    resources = {'cpu': 1.0}
    requests = [{'cpu': 0.4}, {'cpu': 0.5}]  # total 0.9, leaves 0.1
    assert is_allocation_feasible(resources, requests) is True


def test_float_exact_fill_now_infeasible():
    # Float exact fill (NEW RULE)
    resources = {'cpu': 1.0}
    requests = [{'cpu': 0.4}, {'cpu': 0.6}]  # total 1.0, leaves 0.0
    assert is_allocation_feasible(resources, requests) is False


def test_amount_non_numeric_infeasible():
    # Non-Numeric Amount
    resources = {'cpu': 5}
    requests = [{'cpu': "2"}]
    assert is_allocation_feasible(resources, requests) is False
 
--------------------------------------------------




